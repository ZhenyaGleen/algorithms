package com.example.demo.search;

/**
 * Сложность O(nlog n)
 * Работает только на сортированных массивах
 */
public class BinarySearch implements SearchAlgorithm {

    @Override
    public int search(int[] array, int num) {

        // указатель на начало обрабатываемого массива
        int low = 0;

        // указатель на конец обрабатываемого массива
        int high = array.length - 1;

        // пока начальный и конечный индексы не сойдутся, то ...
        while (low <= high) {

            // находим середину массива
            int mid = (low + high) / 2;

            // если искомый элемент больше, чем элемент в центре массива, то ...
            if (num > array[mid]) {

                // перемещаем указатель на начало подмассива за средний элемент,
                // то есть теперь мы будем работать с подмассивом от среднего элемента до конца массива
                low = mid + 1;

            // если искомый элемент меньше, чем элемент в центре массива, то ...
            } else if (num < array[mid]) {

                // перемещаем указатель на конец подмассива перед средним элементом,
                // то есть теперь мы будем работать с подмассивом от начала массива до среднего элемента
                high = mid - 1;
            } else {

                // если элемент в середине не больше, и не меньше, чем искомое число,
                // то значит они равны и мы возвращаем индекс этого элемента
                return mid;
            }
        }

        // если элемент не найден, то возвращаем -1
        // видел примеры, где выбрасывают исключения
        // думаю это зависит от задачи и здесь это будет лишним
        return -1;
    }
}